---
title: "Bias App"
#author: Rolf Grönwold, Tom Palmer, Kate Tilling
output: flexdashboard::flex_dashboard
runtime: shiny
---

```{r setup, include=FALSE}
if (!requireNamespace("DiagrammeR", quietly = TRUE)) install.packages("DiagrammeR")
library(DiagrammeR)

if (!requireNamespace("tidyverse", quietly = TRUE)) install.packages("tidyverse")
library(tidyverse)

if (!requireNamespace("plotly", quietly = TRUE)) install.packages("plotly")
library(plotly)
```

```{r, include=FALSE}
# functions for the biases
confounderbias <-
  function(x = 0.1,
           ratio = 1,
           varc = 1,
           sigma2x = 1,
           rho = NULL,
           vary = NULL,
           varx = NULL) {
    # x is bcx
    if (is.null(rho)) {
      bcy <- x / ratio
      (x * bcy * varc) / (x ^ 2 * varc + sigma2x)
    } else {
      (rho * sqrt(vary)) / sqrt(varx)
    }
  }

colliderbias <-
  function(x = 0.1,
           ratio = 1,
           bxy = 0,
           varx = 1,
           sigma2y = 1,
           sigma2c = 1) {
    # x is bxc
    byc <- x / ratio
    vary <- bxy ^ 2 * varx + sigma2y
    varc <-
      (x ^ 2 * varx) + (byc ^ 2 * vary) + (2 * x * bxy * byc * varx) + sigma2c
    num <- -1 * (bxy * bxy + x) * (vary - bxy ^ 2 * varx) * byc
    den <- varc - varx * (bxy * byc + x) ^ 2
    num / den
  }

selectionbias <-
  function(x = 1,
           bxy = 1,
           sigma2y = 1,
           sigma2s = 1,
           varx = 1) {
    # x is bys
    bys <- x
    vary <- bxy ^ 2 * varx + sigma2y
    vars <- bys ^ 2 * vary + sigma2s
    num <- bxy * (varx * vars - bys ^ 2 * vary * varx) ^ 2
    den <- varx * vars - (bxy * bys * varx) ^ 2
    (num / den) - bxy
  }
```

# Confounding bias {data-height=800}

```{r}
# ui ----
  ui = fluidPage(
    withMathJax(),
      fluidRow(
        column(6,
      p(
        "In this model, shown in the path diagram on the right, we consider the effect of omitting a confounder, \\(C\\), from the regression of \\(Y\\) on \\(X\\)."),
        br(),
        p("The bias in the estimate of \\(\\beta_{xy}\\) when we do not adjust for \\(C\\) is given by: $$\\text{Bias} = \\frac{\\beta_{cx}\\beta_{cy}\\text{var}(C)}{\\beta_{cx}^2\\text{var}(C) + \\sigma_{X}^2}$$"),
        br(),
        p("The plot below visualises this bias. Change the settings to explore how the bias changes."
      )),
      column(6, grVizOutput("confdiagram", width = "250px"))
      ),
  fluidRow(column(12, plotlyOutput("plot1"))),
    fluidRow(
      column(2,
             numericInput("ratio", "Ratio: \\(\\beta_{cx} / \\beta_{cy}\\)", value = 1, step = 0.1, width = "100px")),
      column(2,
             numericInput("varc", "\\(\\text{var}(C)\\)", value = 1, step = 0.1, width = "100px", min = 1e-6)),
      column(2,
             numericInput("sigma2x", "\\(\\sigma^2_{X}\\)", value = 1, step = 0.1, width = "100px", min = 1e-6)),
      column(2,
             numericInput("xmin", "X-axis min", value = -0.2, step = 0.1, width = "100px")),
      column(2,
             numericInput("xmax", "X-axis max", value = 0.2, step = 0.1, width = "100px"))
    )
  )
  
# server ----
  server = function(input, output) {

    output$confdiagram <- renderGrViz({
      grViz({"
      digraph dag {
      graph [rankdir=TB]
      node [shape=plaintext, width=0.3, height=0.3]
      X 
      C 
      Y
      node [shape=circle, height=0.3, fixedsize=true]
      Ex [label='&epsilon;@_{x}']
      Ey [label='&epsilon;@_{y}']
      { rank = same; X Y }
      X -> Y [minlen=3, label='&beta;@_{xy}']
      C -> X [label='&beta;@_{cx}']
      C -> Y [minlen=.5, label='&beta;@_{cy}']
      C -> C [dir='both', headport='n', tailport='n']
      Ex -> X [label='1']
      Ey -> Y [label='1']
      }
      "})
    })
    
    output$plot1 <- renderPlotly({
        ggplotly(
        ggplot(data = data.frame(x = 0), 
               mapping = aes(x = x)) + 
        stat_function(fun = confounderbias, 
                      colour = "blue",
                      args = list(varc = input$varc,
                                  sigma2x = input$sigma2x,
                                  ratio = input$ratio)) +
        scale_x_continuous(limits = c(input$xmin, input$xmax)) + 
        ylab("Bias") + 
        xlab("$\\beta_{cx}$")
      )
    })
  }

# Define as an app ----
shinyApp(ui = ui, server = server)
```

# Collider bias

```{r}
# ui ----
  ui = fluidPage(
    withMathJax(),
      fluidRow(
        column(6,
      p(
        "In this model, shown in the path diagram on the right, we consider the effect of including a collider, \\(C\\), in the regression of \\(Y\\) on \\(X\\) and \\(C\\)."),
        br(),
        p("The bias in the estimate of \\(\\beta_{xy}\\) when we adjust for \\(C\\) is given by: $$\\text{Bias} = -\\frac{(\\beta_{xy}\\beta_{yc} + \\beta_{xc})(\\text{var}(Y)- \\beta_{xy}^2\\text{var}(X))\\beta_{yc}}{\\text{var}(C) - \\text{var}(X)(\\beta_{xy}\\beta_{yc} + \\beta_{xc})^2}$$"),
        br(),
        p("The plot below visualises this bias. Change the settings to explore how the bias changes."
      )),
      column(6, grVizOutput("confdiagram", width = "250px"))
      ),
  fluidRow(column(12, plotlyOutput("plot1"))),
    fluidRow(
      column(2,
             numericInput("ratio", "Ratio: \\(\\beta_{xc} / \\beta_{yc}\\)", value = 1, step = 0.1, width = "100px")),
      column(2,
             numericInput("bxy", "\\(\\beta_{xy}\\)", value = 0, step = 0.1, width = "100px")),
      column(2,
             numericInput("varx", "\\(\\text{var}(X)\\)", value = 1, step = 0.1, width = "100px", min = 1e-6)),
      column(1,
             numericInput("sigma2y", "\\(\\sigma^2_{y}\\)", value = 1, step = 0.1, width = "100px", min = 1e-6)),
      column(1,
             numericInput("sigma2c", "\\(\\sigma^2_{c}\\)", value = 1, step = 0.1, width = "100px", min = 1e-6)),
      column(2,
             numericInput("xmin", "X-axis min", value = -0.2, step = 0.1, width = "100px")),
      column(2,
             numericInput("xmax", "X-axis max", value = 0.2, step = 0.1, width = "100px"))
    )
  )
  
# server ----
  server = function(input, output) {

    output$confdiagram <- renderGrViz({
      grViz({"
      digraph dag {
      graph [rankdir=TB, layout=neato]
      node [shape=box, height=0.4, width=0.4]
      X [pos='0,1!']
      C [pos='1,0!']
      Y [pos='2,1!']
      node [shape=circle, height=0.4, fixedsize=true]
      Ec [label='&epsilon;@_{C}', pos='1,-1!']
      Ey [label='&epsilon;@_{y}', pos='2,2!']
      { rank = same; X Y }
      X -> C [label='&beta;@_{xc}']
      Y -> C [minlen=.5, label='&beta;@_{yc}']
      X -> Y [label='&beta;@_{xy}']
      Ec -> C [label=1]
      X -> X [dir='both', headport='w']
      Ey -> Y [label=1]
      }
      "})
    })
    
    output$plot1 <- renderPlotly({
        ggplotly(
        ggplot(data = data.frame(x = 0), 
               mapping = aes(x = x)) + 
        stat_function(fun = colliderbias, 
                      colour = "blue",
                      args = list(sigma2c = input$sigma2c,
                                  sigma2y = input$sigma2y,
                                  ratio = input$ratio,
                                  bxy = input$bxy,
                                  varx = input$varx)) +
        scale_x_continuous(limits = c(input$xmin, input$xmax)) + 
        ylab("Bias") + 
        xlab("$\\beta_{xc}$")
      )
    })
  }

# Define as an app ----
shinyApp(ui = ui, server = server)
```

# Selection bias

```{r}
# ui ----
  ui = fluidPage(
    withMathJax(),
      fluidRow(
        column(6,
      p(
        "In this model, shown in the path diagram on the right, we consider the effect of adjusting for a variable, S, which is caused by the outcome, i.e. we fit the regression of Y on X and S."),
        br(),
        p("The plot below visualises this bias. Change the settings to explore how the bias changes."
      )),
      column(6, grVizOutput("seldiagram", width = "250px"))
      ),
  fluidRow(column(12, plotlyOutput("plot1"))),
    fluidRow(
      column(2,
             numericInput("bxy", "\\(\\beta_{xy}\\)", value = 1, step = 0.1, width = "100px")),
      column(2,
             numericInput("sigma2y", "\\(\\sigma^2_{Y}\\)", value = 1, step = 0.1, width = "100px", min = 1e-6)),
      column(2,
             numericInput("sigma2s", "\\(\\sigma^2_{S}\\)", value = 1, step = 0.1, width = "100px", min = 1e-6)),
      column(2,
             numericInput("varx", "\\(\\text{var}(X)\\)", value = 1, step = 0.1, width = "100px", min = 1e-6)),
      column(2,
             numericInput("xmin", "X-axis min", value = -0.2, step = 0.1, width = "100px")),
      column(2,
             numericInput("xmax", "X-axis max", value = 0.2, step = 0.1, width = "100px"))
    )
  )
  
# server ----
  server = function(input, output) {

    output$seldiagram <- renderGrViz({
      grViz({"
      digraph dag {
      graph [rankdir=TB]
      node [shape=box, width=0.3, height=0.3]
      X 
      Y
      S
      { rank = same; X Y S }
      node [shape=circle, height=0.35, fixedsize=true]
      Ey [label='&epsilon;@_{Y}']
      Es [label='&epsilon;@_{S}']
      { rank = same; Ey Es }
      X -> Y [minlen=3, label='&beta;@_{xy}']
      Y -> S [minlen=3, label='&beta;@_{ys}']
      X -> X [dir='both', headport='w', tailport='w']
      Ey -> Y [label=1]
      Es -> S [label=1]
      }
      "})
    })
    
    output$plot1 <- renderPlotly({
        ggplotly(
        ggplot(data = data.frame(x = 0), 
               mapping = aes(x = x)) + 
        stat_function(fun = selectionbias, 
                      colour = "blue",
                      args = list(bxy = input$bxy,
                                  sigma2y = input$sigma2y,
                                  sigma2s = input$sigma2s,
                                  varx = input$varx)) +
        scale_x_continuous(limits = c(input$xmin, input$xmax)) + 
        ylab("Bias") + 
        xlab("$\\beta_{ys}$")
      )
    })
  }

# Define as an app ----
shinyApp(ui = ui, server = server)
```

<!--
# Figure 2 - simualtion results
-->

# Mediator with confounding

# Example 1, Figure 4

# Example 2, Figure 6

```{r}
# R code to generate plots that compare bias under 2 analysis strategies:
# 1. analysis without adjustment (bias due to unmeasured confounding) = UC
# 2. analysis with adjustment for an intermediate variable (proxy for unmeasured confounding) = CIUC
# ===============================================
# 
# function that quantifies bias due to unmeasured confounding:
UC <- function(b.mu, b.mx, b.xu, b.ym, b.yu) b.xu*b.yu / (b.xu^2 + 1)

# function that quantifies bias when conditioning on an intermediate:
CIUC <- function(b.mu, b.mx, b.xu, b.ym, b.yu) {
	(b.xu*b.yu - b.mu*b.mx*b.yu)/(b.xu^2 + b.mu^2 + 1) - b.mx*b.ym
}

# function that quantifies difference in absolute bias:
delta.bias <- function(b.mu, b.mx, b.xu, b.ym, b.yu) {
	abs(UC(b.mu,b.mx,b.xu,b.ym,b.yu)) - abs(CIUC(b.mu,b.mx,b.xu,b.ym,b.yu))
}

# ranges of values for different parameters:
b_mu <- seq(0.9, 1.1, length.out = 10)
b_mx <- seq(0.05, 0.15, length.out = 10)
b_xu <- seq(0.15, 0.25, length.out = 10)
b_ym <- seq(1.0, 1.2, length.out = 10)
b_yu <- seq(0.6, 0.8, length.out = 10)

input <- expand.grid(b_mu, b_mx, b_xu, b_ym, b_yu)
diff.bias <- numeric(dim(input)[1])

for (i in 1:length(diff.bias)){
	diff.bias[i] <- delta.bias(input[i,1], input[i,2], input[i,3], input[i,4], input[i,5])
}
mean(diff.bias > 0)

plot(density(diff.bias), yaxt='n', 
	xlab = 'difference in absolute bias', 
	main = '',
	xlim = c(-.3,.3),
	ylab = '')
	lines(x = c(0,0), y = c(0,1e2), lty = 2)
	text(x = -.15, y = 5.5,'favours not conditioning', cex = .8)
	text(x = .2, y = 5.5, 'favours conditioning', cex = .8)
```

# About

This app accompanies our paper *Conditioning on a mediator*. The preprint is available [here](https://osf.io/sj7ch/).

Authors:

- Rolf Grönwold, Department of Clinical Epidemiology/Department of Medical Statistics, Leiden University Medical Centre, Leiden, Netherlands
- Tom Palmer, MRC Integrative Epidemiology Unit and Population Health Sciences, Bristol Medical School, University of Bristol, Bristol, UK
- Kate Tilling, MRC Integrative Epidemiology Unit and Population Health Sciences, Bristol Medical School, University of Bristol, Bristol, UK

Please email, <tom.palmer@bristol.ac.uk>, with any questions or comments or create an issue in the GitHub repo [here](https://github.com/remlapmot/bias-app/issues).